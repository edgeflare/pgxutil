package pgxutil_test

import (
	"context"
	"testing"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/jackc/pgxutil"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestDBIsImplementedByPoolConnAndTx(t *testing.T) {
	t.Parallel()

	var db pgxutil.DB
	var pool *pgxpool.Pool
	var conn *pgx.Conn
	var tx pgx.Tx

	db = pool
	db = conn
	db = tx
	_ = db
}

func TestSelect(t *testing.T) {
	t.Parallel()

	defaultConnTestRunner.RunTest(context.Background(), t, func(ctx context.Context, t testing.TB, conn *pgx.Conn) {
		type Person struct {
			ID   int32
			Name string
			Age  int32
		}

		people, err := pgxutil.Select(ctx, conn, `select n, 'John', 42 from generate_series(1,3) n`, nil, pgx.RowToAddrOfStructByPos[Person])
		require.NoError(t, err)
		require.Len(t, people, 3)
		require.EqualValues(t, 1, people[0].ID)
		require.Equal(t, "John", people[0].Name)
		require.EqualValues(t, 42, people[0].Age)
		require.EqualValues(t, 2, people[1].ID)
		require.Equal(t, "John", people[1].Name)
		require.EqualValues(t, 42, people[1].Age)
		require.EqualValues(t, 3, people[2].ID)
		require.Equal(t, "John", people[2].Name)
		require.EqualValues(t, 42, people[2].Age)
	})
}

func TestSelectNoRows(t *testing.T) {
	t.Parallel()

	defaultConnTestRunner.RunTest(context.Background(), t, func(ctx context.Context, t testing.TB, conn *pgx.Conn) {
		type Person struct {
			ID   int32
			Name string
			Age  int32
		}

		people, err := pgxutil.Select(ctx, conn, `select 1, 'John', 42 where false`, nil, pgx.RowToAddrOfStructByPos[Person])
		require.NoError(t, err)
		require.Len(t, people, 0)
	})
}

func TestSelectRow(t *testing.T) {
	t.Parallel()

	defaultConnTestRunner.RunTest(context.Background(), t, func(ctx context.Context, t testing.TB, conn *pgx.Conn) {
		type Person struct {
			ID   int32
			Name string
			Age  int32
		}

		person, err := pgxutil.SelectRow(ctx, conn, `select 1, 'John', 42`, nil, pgx.RowToAddrOfStructByPos[Person])
		require.NoError(t, err)
		require.EqualValues(t, 1, person.ID)
		require.Equal(t, "John", person.Name)
		require.EqualValues(t, 42, person.Age)
	})
}

func TestSelectRowNoRows(t *testing.T) {
	t.Parallel()

	defaultConnTestRunner.RunTest(context.Background(), t, func(ctx context.Context, t testing.TB, conn *pgx.Conn) {
		type Person struct {
			ID   int32
			Name string
			Age  int32
		}

		person, err := pgxutil.SelectRow(ctx, conn, `select 1, 'John', 42 where false`, nil, pgx.RowToAddrOfStructByPos[Person])
		require.ErrorIs(t, err, pgx.ErrNoRows)
		require.Nil(t, person)
	})
}

func TestInsert(t *testing.T) {
	t.Parallel()

	defaultConnTestRunner.RunTest(context.Background(), t, func(ctx context.Context, t testing.TB, conn *pgx.Conn) {
		_, err := conn.Exec(ctx, `create temporary table t (
	id int primary key generated by default as identity,
	name text not null,
	age int
)`)
		require.NoError(t, err)

		type Person struct {
			ID   int32
			Name string
			Age  int32
		}

		_, err = pgxutil.Insert(ctx, conn, pgx.Identifier{"t"}, []map[string]any{{"name": "John", "age": 42}, {"name": "Jane", "age": 40}})
		require.NoError(t, err)

		people, err := pgxutil.Select(ctx, conn, `select * from t order by id`, nil, pgx.RowToAddrOfStructByPos[Person])
		require.NoError(t, err)
		require.EqualValues(t, 1, people[0].ID)
		require.Equal(t, "John", people[0].Name)
		require.EqualValues(t, 42, people[0].Age)
		require.EqualValues(t, 2, people[1].ID)
		require.Equal(t, "Jane", people[1].Name)
		require.EqualValues(t, 40, people[1].Age)
	})
}

func TestInsertReturning(t *testing.T) {
	t.Parallel()

	defaultConnTestRunner.RunTest(context.Background(), t, func(ctx context.Context, t testing.TB, conn *pgx.Conn) {
		_, err := conn.Exec(ctx, `create temporary table t (
	id int primary key generated by default as identity,
	name text not null,
	age int
)`)
		require.NoError(t, err)

		type Person struct {
			ID   int32
			Name string
			Age  int32
		}

		people, err := pgxutil.InsertReturning(ctx, conn, pgx.Identifier{"t"}, []map[string]any{{"name": "John", "age": 42}, {"name": "Jane", "age": 40}}, "*", pgx.RowToAddrOfStructByPos[Person])
		require.NoError(t, err)
		require.Len(t, people, 2)
		require.EqualValues(t, 1, people[0].ID)
		require.Equal(t, "John", people[0].Name)
		require.EqualValues(t, 42, people[0].Age)
		require.EqualValues(t, 2, people[1].ID)
		require.Equal(t, "Jane", people[1].Name)
		require.EqualValues(t, 40, people[1].Age)

		people, err = pgxutil.Select(ctx, conn, `select * from t order by id`, nil, pgx.RowToAddrOfStructByPos[Person])
		require.NoError(t, err)
		require.EqualValues(t, 1, people[0].ID)
		require.Equal(t, "John", people[0].Name)
		require.EqualValues(t, 42, people[0].Age)
		require.EqualValues(t, 2, people[1].ID)
		require.Equal(t, "Jane", people[1].Name)
		require.EqualValues(t, 40, people[1].Age)
	})
}

func TestInsertSQL(t *testing.T) {
	t.Parallel()

	tests := []struct {
		testName  string
		tableName pgx.Identifier
		rows      []map[string]any
		sql       string
		args      []any
	}{
		{
			testName:  "Single row",
			tableName: pgx.Identifier{"people"},
			rows:      []map[string]any{{"name": "Adam", "sex": "male"}},
			sql:       `insert into "people" ("name", "sex") values ($1, $2) returning *`,
			args:      []any{"Adam", "male"},
		},
		{
			testName:  "Multiple rows",
			tableName: pgx.Identifier{"people"},
			rows:      []map[string]any{{"name": "Adam", "sex": "male"}, {"name": "Eve", "sex": "female"}, {"name": "Cain", "sex": "male"}, {"name": "Abel", "sex": "male"}},
			sql:       `insert into "people" ("name", "sex") values ($1, $2), ($3, $4), ($5, $6), ($7, $8) returning *`,
			args:      []any{"Adam", "male", "Eve", "female", "Cain", "male", "Abel", "male"},
		},
		{
			testName:  "Schema qualified table",
			tableName: pgx.Identifier{"public", "people"},
			rows:      []map[string]any{{"name": "Adam", "sex": "male"}},
			sql:       `insert into "public"."people" ("name", "sex") values ($1, $2) returning *`,
			args:      []any{"Adam", "male"},
		},
		{
			testName:  "Table with special characters",
			tableName: pgx.Identifier{"Bible Characters"},
			rows:      []map[string]any{{"name": "Adam", "sex": "male"}},
			sql:       `insert into "Bible Characters" ("name", "sex") values ($1, $2) returning *`,
			args:      []any{"Adam", "male"},
		},
		{
			testName:  "Column with special characters",
			tableName: pgx.Identifier{"people"},
			rows:      []map[string]any{{"Complete Name": "Adam", "sex": "male"}},
			sql:       `insert into "people" ("Complete Name", "sex") values ($1, $2) returning *`,
			args:      []any{"Adam", "male"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.testName, func(t *testing.T) {
			sql, args := pgxutil.Private_insertSQL(tt.tableName, tt.rows, "*")
			assert.Equal(t, tt.sql, sql)
			assert.Equal(t, tt.args, args)
		})
	}
}

func TestInsertRow(t *testing.T) {
	t.Parallel()

	defaultConnTestRunner.RunTest(context.Background(), t, func(ctx context.Context, t testing.TB, conn *pgx.Conn) {
		_, err := conn.Exec(ctx, `create temporary table t (
	id int primary key generated by default as identity,
	name text not null,
	age int
)`)
		require.NoError(t, err)

		type Person struct {
			ID   int32
			Name string
			Age  int32
		}

		err = pgxutil.InsertRow(ctx, conn, pgx.Identifier{"t"}, map[string]any{"name": "John", "age": 42})
		require.NoError(t, err)

		person, err := pgxutil.SelectRow(ctx, conn, `select * from t where id = $1`, []any{1}, pgx.RowToAddrOfStructByPos[Person])
		require.NoError(t, err)
		require.EqualValues(t, 1, person.ID)
		require.Equal(t, "John", person.Name)
		require.EqualValues(t, 42, person.Age)
	})
}

func TestInsertRowReturning(t *testing.T) {
	t.Parallel()

	defaultConnTestRunner.RunTest(context.Background(), t, func(ctx context.Context, t testing.TB, conn *pgx.Conn) {
		_, err := conn.Exec(ctx, `create temporary table t (
	id int primary key generated by default as identity,
	name text not null,
	age int
)`)
		require.NoError(t, err)

		type Person struct {
			ID   int32
			Name string
			Age  int32
		}

		person, err := pgxutil.InsertRowReturning(ctx, conn, pgx.Identifier{"t"}, map[string]any{"name": "John", "age": 42}, "*", pgx.RowToAddrOfStructByPos[Person])
		require.NoError(t, err)
		require.EqualValues(t, 1, person.ID)
		require.Equal(t, "John", person.Name)
		require.EqualValues(t, 42, person.Age)

		person, err = pgxutil.SelectRow(ctx, conn, `select * from t where id = $1`, []any{person.ID}, pgx.RowToAddrOfStructByPos[Person])
		require.NoError(t, err)
		require.EqualValues(t, 1, person.ID)
		require.Equal(t, "John", person.Name)
		require.EqualValues(t, 42, person.Age)
	})
}

func TestInsertRowSQL(t *testing.T) {
	t.Parallel()

	tests := []struct {
		testName  string
		tableName pgx.Identifier
		values    map[string]any
		sql       string
		args      []any
	}{
		{
			testName:  "Normal",
			tableName: pgx.Identifier{"people"},
			values:    map[string]any{"name": "Adam", "sex": "male"},
			sql:       `insert into "people" ("name", "sex") values ($1, $2) returning *`,
			args:      []any{"Adam", "male"},
		},
		{
			testName:  "Schema qualified table",
			tableName: pgx.Identifier{"public", "people"},
			values:    map[string]any{"name": "Adam", "sex": "male"},
			sql:       `insert into "public"."people" ("name", "sex") values ($1, $2) returning *`,
			args:      []any{"Adam", "male"},
		},
		{
			testName:  "Table with special characters",
			tableName: pgx.Identifier{"Bible Characters"},
			values:    map[string]any{"name": "Adam", "sex": "male"},
			sql:       `insert into "Bible Characters" ("name", "sex") values ($1, $2) returning *`,
			args:      []any{"Adam", "male"},
		},
		{
			testName:  "Column with special characters",
			tableName: pgx.Identifier{"people"},
			values:    map[string]any{"Complete Name": "Adam", "sex": "male"},
			sql:       `insert into "people" ("Complete Name", "sex") values ($1, $2) returning *`,
			args:      []any{"Adam", "male"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.testName, func(t *testing.T) {
			sql, args := pgxutil.Private_insertRowSQL(tt.tableName, tt.values, "*")
			assert.Equal(t, tt.sql, sql)
			assert.Equal(t, tt.args, args)
		})
	}
}

func TestExecRow(t *testing.T) {
	t.Parallel()

	defaultConnTestRunner.RunTest(context.Background(), t, func(ctx context.Context, t testing.TB, conn *pgx.Conn) {
		_, err := conn.Exec(ctx, `create temporary table t (
	id int primary key generated by default as identity,
	name text not null,
	age int
)`)
		require.NoError(t, err)

		type Person struct {
			ID   int32
			Name string
			Age  int32
		}

		people, err := pgxutil.InsertReturning(ctx, conn, pgx.Identifier{"t"}, []map[string]any{{"name": "John", "age": 42}, {"name": "Jane", "age": 40}}, "*", pgx.RowToAddrOfStructByPos[Person])
		require.NoError(t, err)
		require.Len(t, people, 2)
		require.EqualValues(t, 1, people[0].ID)
		require.EqualValues(t, 2, people[1].ID)

		ct, err := pgxutil.ExecRow(ctx, conn, "update t set name = 'Bill' where id = $1", -1)
		require.ErrorIs(t, err, pgx.ErrNoRows)
		require.Equal(t, "UPDATE 0", ct.String())

		ct, err = pgxutil.ExecRow(ctx, conn, "update t set name = 'Bill'")
		require.ErrorContains(t, err, "too many rows")
		require.Equal(t, "UPDATE 2", ct.String())
	})
}

func TestUpdateSQL(t *testing.T) {
	t.Parallel()

	tests := []struct {
		testName    string
		tableName   pgx.Identifier
		setValues   map[string]any
		whereValues map[string]any
		sql         string
		args        []any
	}{
		{
			testName:  "Update all rows",
			tableName: pgx.Identifier{"products"},
			setValues: map[string]any{"color": "green"},
			sql:       `update "products" set "color" = $1 returning *`,
			args:      []any{"green"},
		},
		{
			testName:  "Update multiple columns",
			tableName: pgx.Identifier{"products"},
			setValues: map[string]any{"color": "green", "size": "large"},
			sql:       `update "products" set "color" = $1, "size" = $2 returning *`,
			args:      []any{"green", "large"},
		},
		{
			testName:  "Schema qualified table",
			tableName: pgx.Identifier{"store", "products"},
			setValues: map[string]any{"color": "green"},
			sql:       `update "store"."products" set "color" = $1 returning *`,
			args:      []any{"green"},
		},
		{
			testName:  "Table with special characters",
			tableName: pgx.Identifier{"for sale products"},
			setValues: map[string]any{"color": "green"},
			sql:       `update "for sale products" set "color" = $1 returning *`,
			args:      []any{"green"},
		},
		{
			testName:  "Column with special characters",
			tableName: pgx.Identifier{"products"},
			setValues: map[string]any{"color": "green", "American size": "large"},
			sql:       `update "products" set "American size" = $1, "color" = $2 returning *`,
			args:      []any{"large", "green"},
		},
		{
			testName:    "Update some rows",
			tableName:   pgx.Identifier{"products"},
			setValues:   map[string]any{"color": "green"},
			whereValues: map[string]any{"color": "red"},
			sql:         `update "products" set "color" = $1 where "color" = $2 returning *`,
			args:        []any{"green", "red"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.testName, func(t *testing.T) {
			sql, args := pgxutil.Private_updateSQL(tt.tableName, tt.setValues, tt.whereValues, "*")
			assert.Equal(t, tt.sql, sql)
			assert.Equal(t, tt.args, args)
		})
	}
}

func TestUpdate(t *testing.T) {
	t.Parallel()

	defaultConnTestRunner.RunTest(context.Background(), t, func(ctx context.Context, t testing.TB, conn *pgx.Conn) {
		_, err := conn.Exec(ctx, `create temporary table t (
	id int primary key generated by default as identity,
	name text not null,
	age int
)`)
		require.NoError(t, err)

		type Person struct {
			ID   int32
			Name string
			Age  int32
		}

		ct, err := pgxutil.Update(ctx, conn, pgx.Identifier{"t"}, map[string]any{"age": 42}, nil)
		require.NoError(t, err)
		require.EqualValues(t, 0, ct.RowsAffected())

		_, err = pgxutil.Insert(ctx, conn, pgx.Identifier{"t"}, []map[string]any{{"name": "John", "age": 42}, {"name": "Jane", "age": 40}})
		require.NoError(t, err)

		ct, err = pgxutil.Update(ctx, conn, pgx.Identifier{"t"}, map[string]any{"age": 70}, map[string]any{"name": "John"})
		require.NoError(t, err)
		require.EqualValues(t, 1, ct.RowsAffected())

		people, err := pgxutil.Select(ctx, conn, `select * from t where age = $1`, []any{70}, pgx.RowToAddrOfStructByPos[Person])
		require.NoError(t, err)
		require.Len(t, people, 1)
		require.EqualValues(t, 1, people[0].ID)
		require.Equal(t, "John", people[0].Name)
		require.EqualValues(t, 70, people[0].Age)
	})
}

func TestUpdateReturning(t *testing.T) {
	t.Parallel()

	defaultConnTestRunner.RunTest(context.Background(), t, func(ctx context.Context, t testing.TB, conn *pgx.Conn) {
		_, err := conn.Exec(ctx, `create temporary table t (
	id int primary key generated by default as identity,
	name text not null,
	age int
)`)
		require.NoError(t, err)

		type Person struct {
			ID   int32
			Name string
			Age  int32
		}

		people, err := pgxutil.UpdateReturning(ctx, conn, pgx.Identifier{"t"}, map[string]any{"age": 42}, nil, "*", pgx.RowToAddrOfStructByPos[Person])
		require.NoError(t, err)
		require.Len(t, people, 0)

		people, err = pgxutil.InsertReturning(ctx, conn, pgx.Identifier{"t"}, []map[string]any{{"name": "John", "age": 42}, {"name": "Jane", "age": 40}}, "*", pgx.RowToAddrOfStructByPos[Person])
		require.NoError(t, err)
		require.Len(t, people, 2)

		people, err = pgxutil.UpdateReturning(ctx, conn, pgx.Identifier{"t"}, map[string]any{"age": 70}, map[string]any{"name": "John"}, "*", pgx.RowToAddrOfStructByPos[Person])
		require.NoError(t, err)
		require.Len(t, people, 1)
		require.EqualValues(t, 1, people[0].ID)
		require.Equal(t, "John", people[0].Name)
		require.EqualValues(t, 70, people[0].Age)
	})
}

func TestUpdateRow(t *testing.T) {
	t.Parallel()

	defaultConnTestRunner.RunTest(context.Background(), t, func(ctx context.Context, t testing.TB, conn *pgx.Conn) {
		_, err := conn.Exec(ctx, `create temporary table t (
	id int primary key generated by default as identity,
	name text not null,
	age int
)`)
		require.NoError(t, err)

		type Person struct {
			ID   int32
			Name string
			Age  int32
		}

		err = pgxutil.UpdateRow(ctx, conn, pgx.Identifier{"t"}, map[string]any{"age": 42}, nil)
		require.ErrorIs(t, err, pgx.ErrNoRows)

		people, err := pgxutil.InsertReturning(ctx, conn, pgx.Identifier{"t"}, []map[string]any{{"name": "John", "age": 42}, {"name": "Jane", "age": 40}}, "*", pgx.RowToAddrOfStructByPos[Person])
		require.NoError(t, err)
		require.Len(t, people, 2)

		err = pgxutil.UpdateRow(ctx, conn, pgx.Identifier{"t"}, map[string]any{"age": 70}, map[string]any{"name": "John"})
		require.NoError(t, err)

		err = pgxutil.UpdateRow(ctx, conn, pgx.Identifier{"t"}, map[string]any{"age": 70}, nil)
		require.ErrorContains(t, err, "too many rows")
	})
}

func TestUpdateRowReturning(t *testing.T) {
	t.Parallel()

	defaultConnTestRunner.RunTest(context.Background(), t, func(ctx context.Context, t testing.TB, conn *pgx.Conn) {
		_, err := conn.Exec(ctx, `create temporary table t (
	id int primary key generated by default as identity,
	name text not null,
	age int
)`)
		require.NoError(t, err)

		type Person struct {
			ID   int32
			Name string
			Age  int32
		}

		person, err := pgxutil.UpdateRowReturning(ctx, conn, pgx.Identifier{"t"}, map[string]any{"age": 42}, nil, "*", pgx.RowToAddrOfStructByPos[Person])
		require.ErrorIs(t, err, pgx.ErrNoRows)
		require.Nil(t, person)

		people, err := pgxutil.InsertReturning(ctx, conn, pgx.Identifier{"t"}, []map[string]any{{"name": "John", "age": 42}, {"name": "Jane", "age": 40}}, "*", pgx.RowToAddrOfStructByPos[Person])
		require.NoError(t, err)
		require.Len(t, people, 2)

		person, err = pgxutil.UpdateRowReturning(ctx, conn, pgx.Identifier{"t"}, map[string]any{"age": 70}, map[string]any{"name": "John"}, "*", pgx.RowToAddrOfStructByPos[Person])
		require.NoError(t, err)
		require.NotNil(t, person)
		require.EqualValues(t, 1, person.ID)
		require.Equal(t, "John", person.Name)
		require.EqualValues(t, 70, person.Age)

		_, err = pgxutil.UpdateRowReturning(ctx, conn, pgx.Identifier{"t"}, map[string]any{"age": 70}, nil, "*", pgx.RowToAddrOfStructByPos[Person])
		require.ErrorContains(t, err, "too many rows")
	})
}
